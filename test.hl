// Utility functions

// let not = \b:I.if b then 0 else 1 in
// let or  = \a:I. \b:I. if b then a else 1 in
// let and = \a:I. \b:I. if b then 0 else a in

let lookup_I =
    \n:I. \l:[I].
    (
      (
        fold (\m:I. \acc:(I, I).
          ( acc[0] - 1
          , if acc[0]
              then acc[1]
              else m
          )
        ) with (n, 0)
      ) l
    )[1]
  in

// let length_I = fold (\_:I. \acc:I. acc + 1) with 0 in

// let sum = fold (\m:I. \acc:I. acc + m) with 0 in

// Game related definitions

type map          = [[I]] in
// let mapWall       = 0 in
// let mapEmpty      = 1 in
// let mapPill       = 2 in
// let mapPowerPill  = 3 in
// let mapFruit      = 4 in
// let mapLMStart    = 5 in
// let mapGStart     = 6 in

type lmVitality = I in

type ghostVitality         = I in
// let ghostVitalityStandard  = 0 in
// let ghostVitalityFright    = 1 in
// let ghostVitalityInvisible = 2 in

type direction    = I in
// let dirUp         = 0 in
// let dirRight      = 1 in
// let dirDown       = 2 in
// let dirLeft       = 3 in

type lambdaManStatus = (vitality, (I, I), direction, I, I) in

type ghostStatus = (ghostVitality, (I, I), direction) in

type fruitStatus = I in

type worldState = (map, lambdaManStatus, [ghostStatus], fruitStatus) in

type userState = I in

type stepType = userState -> worldState -> (userState, direction) in

type mainType = worldState -> ? -> (userState, stepType) in

// let step =
//     \u     : userState.
//     \world : worldState.
//     (u, 1)
//   in

// let main =
//     \world : worldState.
//     \_     : ? .
//     (0, step)
//   in

let li = cons 4 with (cons 10 with (cons 42 with (cons 98 with (empty I)))) in

(lookup_I 2) li