let not = \ b:I.if b then 0 else 1 in 

let __internal_btree_set_I_lte = \x:I. \y:I. x <= y in
type __internal_btree_set_I_maybe = <I, I> in

let __internal_btree_set_I_partition_list =
  fold
    ( \x:I. \acc:([I], [I]).
        (cons x with acc[1], acc[0])
    ) with (empty I, empty I)
  in

letrec __internal_btree_set_I_fusion_list : [I] -> [I] -> [I] = \l:[I]. \l_:[I].
  if isempty l
    then l_
  else if isempty l_
    then l
  else if (head l) <= (head l_)
    then cons (head l) with (__internal_btree_set_I_fusion_list (tail l) l_)
  else
    cons (head l_) with (__internal_btree_set_I_fusion_list (tail l_) l)
  in

letrec __internal_btree_set_I_sort_list : [I] -> [I] = \l:[I].
  if isempty l
    then empty I
  else if isempty (tail l)
    then l
  else
    let p = (\ok:([I],[I]). ok) (__internal_btree_set_I_partition_list l) in
    __internal_btree_set_I_fusion_list (__internal_btree_set_I_sort_list p[0]) (__internal_btree_set_I_sort_list p[1])
  in

type btree_set_I = <I, (?, I, ?)> in
let btree_set_I_empty = make btree_set_I 0 0 in
let btree_set_I_node = \l:btree_set_I. \x:I. \r:btree_set_I. make btree_set_I 1 (l, x, r) in


 __internal_btree_set_I_sort_list (cons 2 with cons 1 with cons (0-95) with empty I)
