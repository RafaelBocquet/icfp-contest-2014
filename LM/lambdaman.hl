let not = \ b:I.if b then 0 else 1 in let or  = \ a:I. \ b:I. if b then 1 else a in let and = \ a:I. \ b:I. if b then a else 0 in

let __internal_heap_min_I_eq = \x:I. \y:I. x == y in
let __internal_heap_min_I_lte = \x:I. \y:I. x <= y in
type heap_min_I_maybe = <I, I> in

let heap_min_I_tag_complete = 0 in
let heap_min_I_tag_left = 1 in
let heap_min_I_tag_right = 2 in

type heap_min_I = <I, (I, ?, I, ?)> in

let heap_min_I_tag = destruct (\_:I. heap_min_I_tag_complete, \h:(I, heap_min_I, I, heap_min_I). h[0]) in

let heap_min_I_empty = make heap_min_I 0 0 in
let heap_min_I_node = \l:heap_min_I. \x:I. \r:heap_min_I.
  make heap_min_I 1
    (if heap_min_I_tag l == heap_min_I_tag_complete
      then if heap_min_I_tag r == heap_min_I_tag_complete
        then heap_min_I_tag_complete
        else heap_min_I_tag_right
      else heap_min_I_tag_left
    , l
    , x
    , r
    )
  in
let heap_min_I_singleton = \x:I. heap_min_I_node heap_min_I_empty x heap_min_I_empty in

let heap_min_I_min =
  destruct
    ( \_:I. make heap_min_I_maybe 0 0
    , \h:(I, heap_min_I, I, heap_min_I). make heap_min_I_maybe 1 h[2]
    )
  in

letrec __internal_heap_min_I_insert : I -> heap_min_I -> (heap_min_I, I, heap_min_I) = \x:I.
  destruct
    ( \_:I. (heap_min_I_empty, x, heap_min_I_empty)
    , \h:(I, heap_min_I, I, heap_min_I).
        if h[0] == heap_min_I_tag_right
          then
            let r_ = __internal_heap_min_I_insert x h[3] in
            if __internal_heap_min_I_lte h[2] r_[1]
              then
                (h[1], h[2], heap_min_I_node r_[0] r_[1] r_[2])
              else
                (h[1], r_[1], heap_min_I_node r_[0] h[2] r_[2])
          else
            let l_ = __internal_heap_min_I_insert x h[1] in
            if __internal_heap_min_I_lte h[2] l_[1]
              then
                (heap_min_I_node l_[0] l_[1] l_[2], h[2], h[3])
              else
                (heap_min_I_node l_[0] h[2] l_[2], l_[1], h[3])
    )
  in

let heap_min_I_insert = \x:I. \h:heap_min_I.
  let h_ = __internal_heap_min_I_insert x h in
  heap_min_I_node h_[0] h_[1] h_[2]
  in

letrec __internal_heap_min_I_delete_2 : heap_min_I -> heap_min_I =
  destruct
    ( \_:I. heap_min_I_empty
    , \h:(I, heap_min_I, I, heap_min_I).
        (destruct
          ( \__:I. make heap_min_I 1 h
          , \l:(I, heap_min_I, I, heap_min_I).
            (destruct
              ( \___:I.
                  if __internal_heap_min_I_lte l[2] h[2]
                    then make heap_min_I 1 (h[0], make heap_min_I 1 (l[0], l[1], h[2], l[3]), l[2], h[3])
                    else make heap_min_I 1 h
              , \r:(I, heap_min_I, I, heap_min_I).
                  if and (__internal_heap_min_I_lte l[2] h[2]) (__internal_heap_min_I_lte l[2] r[2])
                    then make heap_min_I 1 (h[0], make heap_min_I 1 (l[0], l[1], h[2], l[3]), l[2], h[3])
                  else if __internal_heap_min_I_lte r[2] h[2]
                    then make heap_min_I 1 (h[0], h[1], r[2], make heap_min_I 1 (r[0], r[1], h[2], r[3]))
                  else make heap_min_I 1 h
              )
            ) h[3]
          )
        ) h[1]
    )
  in

letrec __internal_heap_min_I_delete_1 : (I, heap_min_I, I, heap_min_I) -> (heap_min_I, I) = \h:(I, heap_min_I, I, heap_min_I).
  (destruct
    ( \__:I. (heap_min_I_empty, h[2])
    , \l:(I, heap_min_I, I, heap_min_I).
        (destruct
          ( \___:I.
              let p = __internal_heap_min_I_delete_1 l in
              (heap_min_I_node p[0] h[2] h[3], p[1])
          , \r:(I, heap_min_I, I, heap_min_I).
              if or
                  (h[0] == heap_min_I_tag_complete)
                  (and
                    (h[0] == heap_min_I_tag_right)
                    (r[0] == heap_min_I_tag_complete)
                  )
                then
                  let p = __internal_heap_min_I_delete_1 r in
                  (heap_min_I_node h[1] h[2] p[0], p[1])
                else
                  let p = __internal_heap_min_I_delete_1 l in
                  (heap_min_I_node p[0] h[2] h[3], p[1])
          ) 
        ) h[3]
    )
  ) h[1]
  in

let heap_min_I_delete = 
  destruct
    ( \_:I. heap_min_I_empty
    , \h:(I, heap_min_I, I, heap_min_I).
        let p = __internal_heap_min_I_delete_1 h in
        ( destruct
            ( \_:I. heap_min_I_empty
            , \p_:(I, heap_min_I, I, heap_min_I).
                __internal_heap_min_I_delete_2 (heap_min_I_node p_[1] p[1] p_[3])
            )
        ) p[0]
    )
  in



let __internal_heap_min_II_eq = \x:(I, I). \y:(I, I). if x[0] == y[0] then x[1] == y[1] else 0 in
let __internal_heap_min_II_lte = \x:(I, I). \y:(I, I). if x[0] == y[0] then x[1] <= y[1] else x[0] <= y[0] in
type heap_min_II_maybe = <I, (I, I)> in

let heap_min_II_tag_complete = 0 in
let heap_min_II_tag_left = 1 in
let heap_min_II_tag_right = 2 in

type heap_min_II = <I, (I, ?, (I, I), ?)> in

let heap_min_II_tag = destruct (\_:I. heap_min_II_tag_complete, \h:(I, heap_min_II, (I, I), heap_min_II). h[0]) in

let heap_min_II_empty = make heap_min_II 0 0 in
let heap_min_II_node = \l:heap_min_II. \x:(I, I). \r:heap_min_II.
  make heap_min_II 1
    (if heap_min_II_tag l == heap_min_II_tag_complete
      then if heap_min_II_tag r == heap_min_II_tag_complete
        then heap_min_II_tag_complete
        else heap_min_II_tag_right
      else heap_min_II_tag_left
    , l
    , x
    , r
    )
  in
let heap_min_II_singleton = \x:(I, I). heap_min_II_node heap_min_II_empty x heap_min_II_empty in

let heap_min_II_min =
  destruct
    ( \_:I. make heap_min_II_maybe 0 0
    , \h:(I, heap_min_II, (I, I), heap_min_II). make heap_min_II_maybe 1 h[2]
    )
  in

letrec __internal_heap_min_II_insert : (I, I) -> heap_min_II -> (heap_min_II, (I, I), heap_min_II) = \x:(I, I).
  destruct
    ( \_:I. (heap_min_II_empty, x, heap_min_II_empty)
    , \h:(I, heap_min_II, (I, I), heap_min_II).
        if h[0] == heap_min_II_tag_right
          then
            let r_ = __internal_heap_min_II_insert x h[3] in
            if __internal_heap_min_II_lte h[2] r_[1]
              then
                (h[1], h[2], heap_min_II_node r_[0] r_[1] r_[2])
              else
                (h[1], r_[1], heap_min_II_node r_[0] h[2] r_[2])
          else
            let l_ = __internal_heap_min_II_insert x h[1] in
            if __internal_heap_min_II_lte h[2] l_[1]
              then
                (heap_min_II_node l_[0] l_[1] l_[2], h[2], h[3])
              else
                (heap_min_II_node l_[0] h[2] l_[2], l_[1], h[3])
    )
  in

let heap_min_II_insert = \x:(I, I). \h:heap_min_II.
  let h_ = __internal_heap_min_II_insert x h in
  heap_min_II_node h_[0] h_[1] h_[2]
  in

letrec __internal_heap_min_II_delete_2 : heap_min_II -> heap_min_II =
  destruct
    ( \_:I. heap_min_II_empty
    , \h:(I, heap_min_II, (I, I), heap_min_II).
        (destruct
          ( \__:I. make heap_min_II 1 h
          , \l:(I, heap_min_II, (I, I), heap_min_II).
            (destruct
              ( \___:I.
                  if __internal_heap_min_II_lte l[2] h[2]
                    then make heap_min_II 1 (h[0], make heap_min_II 1 (l[0], l[1], h[2], l[3]), l[2], h[3])
                    else make heap_min_II 1 h
              , \r:(I, heap_min_II, (I, I), heap_min_II).
                  if and (__internal_heap_min_II_lte l[2] h[2]) (__internal_heap_min_II_lte l[2] r[2])
                    then make heap_min_II 1 (h[0], make heap_min_II 1 (l[0], l[1], h[2], l[3]), l[2], h[3])
                  else if __internal_heap_min_II_lte r[2] h[2]
                    then make heap_min_II 1 (h[0], h[1], r[2], make heap_min_II 1 (r[0], r[1], h[2], r[3]))
                  else make heap_min_II 1 h
              )
            ) h[3]
          )
        ) h[1]
    )
  in

letrec __internal_heap_min_II_delete_1 : (I, heap_min_II, (I, I), heap_min_II) -> (heap_min_II, (I, I)) = \h:(I, heap_min_II, (I, I), heap_min_II).
  (destruct
    ( \__:I. (heap_min_II_empty, h[2])
    , \l:(I, heap_min_II, (I, I), heap_min_II).
        (destruct
          ( \___:I.
              let p = __internal_heap_min_II_delete_1 l in
              (heap_min_II_node p[0] h[2] h[3], p[1])
          , \r:(I, heap_min_II, (I, I), heap_min_II).
              if or
                  (h[0] == heap_min_II_tag_complete)
                  (and
                    (h[0] == heap_min_II_tag_right)
                    (r[0] == heap_min_II_tag_complete)
                  )
                then
                  let p = __internal_heap_min_II_delete_1 r in
                  (heap_min_II_node h[1] h[2] p[0], p[1])
                else
                  let p = __internal_heap_min_II_delete_1 l in
                  (heap_min_II_node p[0] h[2] h[3], p[1])
          ) 
        ) h[3]
    )
  ) h[1]
  in

let heap_min_II_delete = 
  destruct
    ( \_:I. heap_min_II_empty
    , \h:(I, heap_min_II, (I, I), heap_min_II).
        let p = __internal_heap_min_II_delete_1 h in
        ( destruct
            ( \_:I. heap_min_II_empty
            , \p_:(I, heap_min_II, (I, I), heap_min_II).
                __internal_heap_min_II_delete_2 (heap_min_II_node p_[1] p[1] p_[3])
            )
        ) p[0]
    )
  in



let __internal_heap_min_V_eq = 
let __cmpeq = \x:(I, I). \y:(I, I). if x[0] == y[0] then x[1] == y[1] else 0 in
\x:((I,I),(I,I)). \y:((I,I),(I,I)). if __cmpeq x[0] y[0] then __cmpeq x[1] y[1] else 0
 in
let __internal_heap_min_V_lte = 
let __cmplte = \x:(I, I). \y:(I, I). if x[0] == y[0] then x[1] <= y[1] else x[0] <= y[0] in
let __cmpeq = \x:(I, I). \y:(I, I). if x[0] == y[0] then x[1] == y[1] else 0 in
\x:((I,I),(I,I)). \y:((I,I),(I,I)). if __cmpeq x[0] y[0] then __cmplte x[1] y[1] else __cmplte x[0] y[0]
 in
type heap_min_V_maybe = <I, ((I,I),(I,I))> in

let heap_min_V_tag_complete = 0 in
let heap_min_V_tag_left = 1 in
let heap_min_V_tag_right = 2 in

type heap_min_V = <I, (I, ?, ((I,I),(I,I)), ?)> in

let heap_min_V_tag = destruct (\_:I. heap_min_V_tag_complete, \h:(I, heap_min_V, ((I,I),(I,I)), heap_min_V). h[0]) in

let heap_min_V_empty = make heap_min_V 0 0 in
let heap_min_V_node = \l:heap_min_V. \x:((I,I),(I,I)). \r:heap_min_V.
  make heap_min_V 1
    (if heap_min_V_tag l == heap_min_V_tag_complete
      then if heap_min_V_tag r == heap_min_V_tag_complete
        then heap_min_V_tag_complete
        else heap_min_V_tag_right
      else heap_min_V_tag_left
    , l
    , x
    , r
    )
  in
let heap_min_V_singleton = \x:((I,I),(I,I)). heap_min_V_node heap_min_V_empty x heap_min_V_empty in

let heap_min_V_min =
  destruct
    ( \_:I. make heap_min_V_maybe 0 0
    , \h:(I, heap_min_V, ((I,I),(I,I)), heap_min_V). make heap_min_V_maybe 1 h[2]
    )
  in

letrec __internal_heap_min_V_insert : ((I,I),(I,I)) -> heap_min_V -> (heap_min_V, ((I,I),(I,I)), heap_min_V) = \x:((I,I),(I,I)).
  destruct
    ( \_:I. (heap_min_V_empty, x, heap_min_V_empty)
    , \h:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
        if h[0] == heap_min_V_tag_right
          then
            let r_ = __internal_heap_min_V_insert x h[3] in
            if __internal_heap_min_V_lte h[2] r_[1]
              then
                (h[1], h[2], heap_min_V_node r_[0] r_[1] r_[2])
              else
                (h[1], r_[1], heap_min_V_node r_[0] h[2] r_[2])
          else
            let l_ = __internal_heap_min_V_insert x h[1] in
            if __internal_heap_min_V_lte h[2] l_[1]
              then
                (heap_min_V_node l_[0] l_[1] l_[2], h[2], h[3])
              else
                (heap_min_V_node l_[0] h[2] l_[2], l_[1], h[3])
    )
  in

let heap_min_V_insert = \x:((I,I),(I,I)). \h:heap_min_V.
  let h_ = __internal_heap_min_V_insert x h in
  heap_min_V_node h_[0] h_[1] h_[2]
  in

letrec __internal_heap_min_V_delete_2 : heap_min_V -> heap_min_V =
  destruct
    ( \_:I. heap_min_V_empty
    , \h:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
        (destruct
          ( \__:I. make heap_min_V 1 h
          , \l:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
            (destruct
              ( \___:I.
                  if __internal_heap_min_V_lte l[2] h[2]
                    then make heap_min_V 1 (h[0], make heap_min_V 1 (l[0], l[1], h[2], l[3]), l[2], h[3])
                    else make heap_min_V 1 h
              , \r:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
                  if and (__internal_heap_min_V_lte l[2] h[2]) (__internal_heap_min_V_lte l[2] r[2])
                    then make heap_min_V 1 (h[0], make heap_min_V 1 (l[0], l[1], h[2], l[3]), l[2], h[3])
                  else if __internal_heap_min_V_lte r[2] h[2]
                    then make heap_min_V 1 (h[0], h[1], r[2], make heap_min_V 1 (r[0], r[1], h[2], r[3]))
                  else make heap_min_V 1 h
              )
            ) h[3]
          )
        ) h[1]
    )
  in

letrec __internal_heap_min_V_delete_1 : (I, heap_min_V, ((I,I),(I,I)), heap_min_V) -> (heap_min_V, ((I,I),(I,I))) = \h:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
  (destruct
    ( \__:I. (heap_min_V_empty, h[2])
    , \l:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
        (destruct
          ( \___:I.
              let p = __internal_heap_min_V_delete_1 l in
              (heap_min_V_node p[0] h[2] h[3], p[1])
          , \r:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
              if or
                  (h[0] == heap_min_V_tag_complete)
                  (and
                    (h[0] == heap_min_V_tag_right)
                    (r[0] == heap_min_V_tag_complete)
                  )
                then
                  let p = __internal_heap_min_V_delete_1 r in
                  (heap_min_V_node h[1] h[2] p[0], p[1])
                else
                  let p = __internal_heap_min_V_delete_1 l in
                  (heap_min_V_node p[0] h[2] h[3], p[1])
          ) 
        ) h[3]
    )
  ) h[1]
  in

let heap_min_V_delete = 
  destruct
    ( \_:I. heap_min_V_empty
    , \h:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
        let p = __internal_heap_min_V_delete_1 h in
        ( destruct
            ( \_:I. heap_min_V_empty
            , \p_:(I, heap_min_V, ((I,I),(I,I)), heap_min_V).
                __internal_heap_min_V_delete_2 (heap_min_V_node p_[1] p[1] p_[3])
            )
        ) p[0]
    )
  in


let h = heap_min_I_insert 2
  (heap_min_I_insert 8
  (heap_min_I_insert 0
  (heap_min_I_insert 95
  (heap_min_I_empty)))) in

trace (heap_min_I_min h) in

let h_ = heap_min_I_delete h in
trace (heap_min_I_min h_) in

let h__ = heap_min_I_delete h_ in
trace (heap_min_I_min h__) in

let h___ = heap_min_I_delete h__ in
trace (heap_min_I_min h___) in

0